\documentclass[preprint]{sigplanconf}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%


\usepackage{enumerate}
\usepackage{subfigure}
\usepackage{fancyvrb}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{xypic}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{url}
\usepackage{color}

\ifdefined\nolhs
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\else
\fi

\bibliographystyle{amsalpha}

\newcommand{\note}[1]{{\color{blue}{#1}}}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\theoremstyle{definition}
\newtheorem{definition}{Definition}

\newcommand{\play}{\mathsf{play}\;}
\newcommand{\playOp}{\textsf{play}}

\newcommand{\sleep}{\mathsf{sleep}\;}
\newcommand{\sleepOp}{\textsf{sleep}}

\newcommand{\ksleep}{\mathsf{kernelSleep}\;}
\newcommand{\ksleepOp}{\textsf{kernelSleep}}

\newcommand{\lang}{SonicPi}

\newcommand{\vtime}[1]{[#1]_{\mathsf{v}}}
\newcommand{\etime}[1]{[#1]_{\mathsf{t}}}

\newcommand{\interp}[1]{\llbracket{#1}\rrbracket}

\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}

\authorinfo{Sam Aaron}{}{}
\authorinfo{Dominic Orchard}{}{}
\title{A programming model for temporal coordination (in music)}

\begin{document}
\maketitle

\section{Introduction}

\note{Introduction to SonicPi}

The underlying programming model of SonicPi provides a way to separate
the ordering of effects from the timing of
effects. Figure~\ref{three-chord-example} shows an example program
where three chords are played in sequence, combining simple notions of 
parallel, timed, and ordered effects. The first three statements play
the notes of a C major chord in parallel. A \sleepOp{} statement then 
provides a \emph{barrier}




Thus ``$\sleep{} t$'' communicates that, after it has been evaluated, at least 
$t$ seconds has elapsed since the last \sleepOp{}. This provides a minimum
time. In between calls to \sleepOp{}, any other statements can (with some limits)
be considered task parallel. 

In \lang{}, it is possible that a computation proceeding a \sleepOp{}
can overrun; that is, run longer than the sleep time.  Thus, the
programming model is not suitable for realtime systems requiring hard
deadlines but \sleepOp{} instead provides a \emph{soft deadline} (using
the terminology of Hansson and Jonsson~\cite{hansson1994logic}).


\begin{itemize}
\item A computational model of virtual and real time 
      structured by an \emph{applicative functor} abstraction.

\item We show that the applicative approach extends
      to a monadic approach, which can be composed with additional
      monads to capture other useful notions of effect in \lang{} programs,
      such as random numbers (Section~\ref{}).
\end{itemize}

Previously reported on the language~\cite{aaron2013sonic}

\begin{figure}[t]
\subfigure[Three chord program in \lang{}]{
\begin{minipage}{0.46\linewidth}
\[
\hspace{-6em}
\begin{array}{l}
\play C \\
\play E \\ 
\play G \\
\sleep 1 \\
\play F \\
\play A \\
\play C \\
\sleep 0.5 \\
\play G \\
\play B \\
\play D \\
\end{array}
\]
\end{minipage}
\label{three-chord-example}
}
\subfigure[Timing of the three chord program]{
\begin{minipage}{0.46\linewidth}
\note{insert nice diagram that shows when the notes
occur over the 1.5s duration} \\
\end{minipage}
\label{three-chord-timing}
}
\caption{Playing three chords (C major, F major, G major) 
in \lang{} with the second two chords played
closer together by $0.5s$.}
\end{figure}

\subsection{Examples}
\label{sec:examples}

\note{Show a few more example programs here that
demonstrate the programming model.}

Figure~\ref{sleep-examples} shows four similar programs which each
have different internal behaviours for \sleepOp, illustrating the
semantics of \sleepOp{}. The first three take 3s to execute and the
last takes 4s to execute, with the behaviours:
%
\begin{enumerate}[(a)]
\item{3s -- sleeps for 1s then sleeps for 2s (two sleeps performed);}
\item{3s -- performs a computation lasting 1s, ignores
the first \sleepOp{} since its minimum deadline has been reached, 
and then sleeps for 2s (one sleep performed);}
\item{3s -- performs a computation lasting 2s, which means that
the first \sleepOp{} is ignored, and the second \sleepOp{} waits
for only 1s to reach its minimum deadline (half a sleep performed);}
\item{4s -- performs a computation lasting 2s, thus 
the first \sleepOp{} is ignored, then performs a computation lasting
2s, thus the second \sleepOp{} is ignored (no sleeps performed).}
\end{enumerate}


\begin{figure}[t]
\subfigure[Two sleeps]{
\begin{minipage}{0.18\linewidth}
\[
\hspace{-1em}
\begin{array}{l}
\sleep 1 \\
\sleep 2 \\ \\ \\ \\
\end{array}
\]
\end{minipage}
\label{sleep-examples:a}
}
\rule[-2em]{0.3pt}{5em}
%\hspace{1em}
% takes 3
\subfigure[One sleep]{
\begin{minipage}{0.23\linewidth}
\begin{center}
\[
\hspace{-0.5em}
\begin{array}{l}
\ldots \; \textit{\# lasts 1s} \\
\sleep 1 \\
\sleep 2 \\ \\  \\
\end{array}
\]
\end{center}
\end{minipage}
\label{sleep-examples:b}
}
\rule[-2em]{0.3pt}{5em}
%\hspace{1em}
% takes 3s
\subfigure[Half a sleep]{
\begin{minipage}{0.23\linewidth}
\begin{center}
\[
\hspace{-0.5em}
\begin{array}{l}
\ldots \; \textit{\# lasts 2s} \\
\sleep 1 \\
\sleep 2 \\ \\ \\
\end{array}
\]
\end{center}
\end{minipage}
\label{sleep-examples:c}
% takes 6
}
\rule[-2em]{0.3pt}{5em}
\subfigure[No sleeps]{
\begin{minipage}{0.23\linewidth}
\begin{center}
\[
\hspace{-0.5em}
\begin{array}{l}
\ldots \; \textit{\# lasts 2s} \\
\sleep 1 \\
\ldots \; \textit{\# lasts 2s} \\
\sleep 2 \\  \\
\end{array}
\]
\end{center}
\end{minipage}
}

\caption{Example programs with different \sleepOp{} behaviours}
\label{sleep-examples}
\end{figure}



\section{Model}

\paragraph{Terminology and notation}
We refer to closed sequences of statements (\ie{}, without free
variables) as \emph{programs}. Throughout, $P$, $Q$ range over programs,
and $s, t$ range over times (usually in seconds).

\subsection{Virtual time and real time}

The programming model of \lang{} distinguishes between the
\emph{actual time} elapsed since the start of a program $P$, which we
write as $\etime{P}$, and the \emph{virtual time} which is advanced by
\sleepOp{} statements, written $\vtime{P}$.

Since \sleepOp{} is the only operation that changes the virtual
time, we can specification for $\vtime{-}$ over all programs:
%
\begin{definition}
Virtual time is specified for statements of \lang{} programs 
by the following (ordered) cases:
%
\begin{align*}
\vtime{\sleep t} & = t \\ 
\vtime{P; Q} & = \vtime{P} + \vtime{Q} \\
\vtime{-} & = 0
\end{align*}
%
\ie{}, the virtual time is $0$ 
for any statment other than \sleepOp{} or sequential composition.
\label{sleep-spec}
\end{definition}

Equality of computation times is difficult. In order to not sweep this
issue entirely under the carpet, we will use the relation $\approx$,
where $s \approx t$ means that $s$ and $t$ are either exactly equal or
differ by some amount $\epsilon$.\note{Discuss this further, may be
  able to say later that in some cases $\epsilon$ is the scheduling
  time for play statments?}  The virtual time and actual time of a
single sleep statement (in isolation) are roughly the same, \ie{},
$\vtime{\sleep t} \approx \etime{\sleep t}$ and thus $\vtime{\sleep t}
\approx t$ by the specification in Definition~\ref{sleep-spec}.

We should be clear however, that this approximate equality does not always
hold. We can only say that it holds when \sleepOp{} is used in isolation, that is, 
when it is the only statement in a program. As shown by the examples
of Section~\ref{sec:examples}, the use of $\sleep t$ in a program 
does not mean that a program necessarily waits for $t$ seconds-- 
depending on the context, it may wait for anywhere between $0$ and $t$ seconds.
 
For convenience, and to contrast with \sleepOp{}, we'll use an additional
statement \ksleepOp{} here (which is not available in the actual language)
 which always sleeps for the number of seconds specified by its parameter.




\begin{lemma}
For some program $P$ and time $s$: 
%%
\begin{align*}
\etime{P; \sleep{} s} = 
 \begin{cases}
   s + \vtime{P} & \etime{P} \leq s \\
   \etime{P} & \etime{P} > s
 \end{cases}
\end{align*}
\label{lem:sleep-R}
\end{lemma}

\begin{lemma}
For some program $P$ and time $s$:
%%
\begin{align*}
\etime{\sleep{} s; P} = s + \etime{P}
\end{align*}
\label{lem:sleep-L}
\end{lemma}

\begin{lemma}
For all programs $P$ then $\etime{P} \geq \vtime{P}$. 
\label{lemma1}
\end{lemma}

\begin{theorem}
For all programs $P$ and $Q$ then:
%%
\begin{equation}
\vtime{P} + \vtime{Q} \leq \etime{P; Q} \leq \etime{P} + \etime{Q}
\end{equation}
\label{len:sleep}
\end{theorem}

\paragraph{Proof}
Since sequential composition is associative, we can reassociate
$P; Q$ such that $P = P_1; P'$ where $P_1$ is a single statement

\begin{itemize}
\item $P = \sleep t$

\begin{align*}
\begin{array}{ll}
       & \etime{\sleep t; Q} \\[0.5em]
\equiv & \; \{\textit{Lemma}~\ref{lem:sleep-L}\} \\[0.1em]
       & s + \etime{Q} \\[0.5em]
\equiv & \; \{\textit{Definition}~\ref{}\} \\[0.1em]
       & \etime{\sleep t} + \etime{Q}
\end{array}
\end{align*}

\item $Q = \sleep t$

\begin{itemize}
\item $\etime{P} \leq t$ then:

\begin{align*}
\begin{array}{ll}
       & \etime{P; \sleep t} \\[0.5em]
\equiv & \; \{\textit{Lemma}~\ref{lem:sleep-R}\} \\[0.1em]
       & \vtime{P} + t \\[0.5em]
\equiv & \; \{\textit{Definition}~\ref{sleep-spec}\} \\[0.1em]
       & \vtime{P} + \vtime{\sleep t}
\end{array}
\end{align*}

 $\etime{P; \sleep t} = \etime{P} + $ 


\end{itemize}

\item $P = P';P'', Q = Q';Q''$

By induction:
%%
\begin{align}
\vtime{P'} + \vtime{P''} \leq \etime{P'; P''} \leq \vtime{P'} + \vtime{P''} \\
\vtime{Q'} + \vtime{Q''} \leq \etime{Q'; Q''} \leq \vtime{Q'} + \vtime{Q''} \\
\end{align}


and


\end{itemize}


For example, consider subprograms $A$, $B$, $C$ interposed with two
sleep statements with lengths $s_1$ and $s_2$:
%
\begin{equation}
\begin{array}{l}
A \\
\sleep s_1 \\
B  \\
\sleep s_2 \\
C
\end{array}
\label{example:time1}
\end{equation}
%%
If $[A] = t_1$, $[B] = t_2$, $[C] = t_3$, then $[eq. \eqref{example:time1}] = 
s_1 + s_2 + t_3$, iff $t_1 \leq 1$ and $t_2 \leq 2$.

%\begin{equation*}
%\begin{array}{lllll}
%A & \multirow{2}{*}{\rule[1em]{0.6pt}{1.2em}} & \multirow{2}{*}{$t_1$} & 
%\multirow{4}{*}{\rule[1em]{0.6pt}{4em}} & \multirow{4}{*}{$t_1 + t_2 + 3$}
%\\
%\emph{sleep} \; 1 \qquad \\
%B &  \multirow{2}{*}{\rule[1em]{0.6pt}{1.2em}} & \multirow{2}{*}{$t_2$} \\
%\emph{sleep} \; 2
%\end{array}
%\end{equation*}

\subsection{Applicative structure on computation}

In the following, we use Haskell as our meta language for the
semantics (since it provides convenient syntax for working with
monads)\footnote{The source code for the model is avilable at
  \url{https://github.com/dorchard/time-monad}}.

\newcommand{\TM}{\mathsf{TM}}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Temporal}\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Conid{T}\;((\Conid{Time},\Conid{Time})\to (\Conid{VTime}\to \Conid{IO}\;(\Varid{a},\Conid{VTime}))){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%%
Which maps a pair of two times, which will be the
start time of the computation and current time, to
a stateful computation over the \emph{IO} monad with
a single location storing a virtual time. The \emph{IO}
computation provides underlying access to the actual
time from kernel. 


To model \lang{}, it is enough for \emph{Temporal} to have the
structure of an \emph{applicative functor}~\cite{mcbride2008functional} (also called
\emph{idioms} or \emph{monoidal functors}).  Recall the usual
applicative functor interface in Haskell:
%%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;\Conid{Functor}\;\Varid{f}\Rightarrow \Conid{Applicative}\;\Varid{f}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{pure}{}\<[10]%
\>[10]{}\mathbin{::}\Varid{a}\to \Varid{f}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}(<\!\!\!*\!\!\!>)\mathbin{::}\Varid{f}\;(\Varid{a}\to \Varid{b})\to \Varid{f}\;\Varid{a}\to \Varid{f}\;\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%%
The \emph{Applicative} interface describes how to compose effectul
computations encoded as values of type $f\ a$ (the effectful computation
of a pure value of type $a$). Thus, \emph{pure} constructs a trivially
effectful computation from a pure value. The \ensuremath{<\!\!\!*\!\!\!>} operation (which we'll
call \emph{apply}) takes an effectful computation of a function and
an effectful computation of an argument and evaluates the two effects


The \emph{Applicative} instance for \emph{Temporal} is:
%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{44}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Applicative}\;\Conid{Temporal}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{pure}\;\Varid{a}{}\<[21]%
\>[21]{}\mathrel{=}\Conid{T}\;(\lambda (\anonymous ,\anonymous )\to \lambda \Varid{vt}\to \Varid{return}\;(\Varid{a},\Varid{vt})){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}(\Conid{T}\;\Varid{f})<\!\!\!*\!\!\!>(\Conid{T}\;\Varid{x})\mathrel{=}\Conid{T}\;(\lambda (\Varid{startT},\Varid{nowT})\to \lambda \Varid{vT}\to {}\<[E]%
\\
\>[5]{}\hsindent{25}{}\<[30]%
\>[30]{}\mathbf{do}\;\Varid{thenT}{}\<[44]%
\>[44]{}\leftarrow \Varid{getCurrentTime}{}\<[E]%
\\
\>[30]{}\hsindent{3}{}\<[33]%
\>[33]{}(\Varid{f'},\Varid{vT'}){}\<[44]%
\>[44]{}\leftarrow \Varid{f}\;(\Varid{startT},\Varid{thenT})\;\Varid{vT}{}\<[E]%
\\
\>[30]{}\hsindent{3}{}\<[33]%
\>[33]{}(\Varid{x'},\Varid{vT''})\leftarrow \Varid{x}\;(\Varid{startT},\Varid{nowT})\;\Varid{vT'}{}\<[E]%
\\
\>[30]{}\hsindent{3}{}\<[33]%
\>[33]{}\Varid{return}\;(\Varid{f'}\;\Varid{x'},\Varid{vT''})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%
The result of composing two temporal computations, with
start time \emph{starT}, current time \emph{nowT}, and virtual
time \emph{vT}, is the result of evaluating first the right 
hand side, and then the left hand side 

Note this gives a left-to-right evaluation order on the appicative
\emph{apply} operation. 

To understand this ordering, consider 


\begin{align*}
\interp{\emph{statement}} & : \emph{Temporal} \, () \\
\interp{P; Q} & = (\lambda() \rightarrow \interp{P}) <\!\!\!*\!\!\!> \interp{Q} \\
\interp{\sleep t} & = \emph{sleep} \, \interp{t}
\end{align*}
%%
Note that $\interp{-}$ is overloaded in the rule for \sleepOp{} for (pure) expressions. 
The concrete interpreation of other statements in the language, such as \playOp, is
elided here since it does not relate directly to the temporal semantics. 

\begin{figure}[t]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{time}\mathbin{::}\Conid{Temporal}\;\Conid{Time}{}\<[E]%
\\
\>[B]{}\Varid{time}{}\<[7]%
\>[7]{}\mathrel{=}\Conid{T}\;(\lambda (\anonymous ,\Varid{nowT})\to \lambda \Varid{vT}\to \Varid{return}\;(\Varid{nowT},\Varid{vT})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{start}\mathbin{::}\Conid{Temporal}\;\Conid{Time}{}\<[E]%
\\
\>[B]{}\Varid{start}\mathrel{=}\Conid{T}\;(\lambda (\Varid{startT},\anonymous )\to \lambda \Varid{vT}\to \Varid{return}\;(\Varid{startT},\Varid{vT})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{getVirtualTime}\mathbin{::}\Conid{Temporal}\;\Conid{VTime}{}\<[E]%
\\
\>[B]{}\Varid{getVirtualTime}\mathrel{=}\Conid{T}\;(\lambda (\anonymous ,\anonymous )\to \lambda \Varid{vT}\to \Varid{return}\;(\Varid{vT},\Varid{vT})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{setVirtualTime}\mathbin{::}\Conid{VTime}\to \Conid{Temporal}\;(){}\<[E]%
\\
\>[B]{}\Varid{setVirtualTime}\;\Varid{vT}\mathrel{=}\Conid{T}\;(\lambda \anonymous \to \lambda \anonymous \to \Varid{return}\;((),\Varid{vT})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{kernelSleep}\mathbin{::}\Conid{RealFrac}\;\Varid{a}\Rightarrow \Varid{a}\to \Conid{Temporal}\;(){}\<[E]%
\\
\>[B]{}\Varid{kernelSleep}\;\Varid{t}\mathrel{=}{}\<[18]%
\>[18]{}\Conid{T}\;(\lambda (\anonymous ,\anonymous )\to \lambda \Varid{vT}\to {}\<[E]%
\\
\>[18]{}\hsindent{6}{}\<[24]%
\>[24]{}\mathbf{do}\;{}\<[28]%
\>[28]{}\Varid{threadDelay}\;(\Varid{round}\;(\Varid{t}\mathbin{*}\mathrm{1000000})){}\<[E]%
\\
\>[28]{}\Varid{return}\;((),\Varid{vT})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{Simple \emph{Temporal} computations, used  by the model}
\end{figure}

The key primitive \emph{sleep} provides the semantics for \sleepOp{} as:
%%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{sleep}\mathbin{::}\Conid{VTime}\to \Conid{Temporal}\;(){}\<[E]%
\\
\>[B]{}\Varid{sleep}\;\Varid{delayT}\mathrel{=}\mathbf{do}\;{}\<[20]%
\>[20]{}\Varid{vT}{}\<[28]%
\>[28]{}\leftarrow \Varid{getVirtualTime}{}\<[E]%
\\
\>[20]{}\Varid{startT}{}\<[28]%
\>[28]{}\leftarrow \Varid{start}{}\<[E]%
\\
\>[20]{}\Varid{nowT}{}\<[28]%
\>[28]{}\leftarrow \Varid{time}{}\<[E]%
\\
\>[20]{}\mathbf{let}\;\Varid{vT'}{}\<[30]%
\>[30]{}\mathrel{=}\Varid{vT}\mathbin{+}\Varid{delayT}{}\<[E]%
\\
\>[20]{}\mathbf{let}\;\Varid{diffT}\mathrel{=}\Varid{diffTime}\;\Varid{nowT}\;\Varid{startT}{}\<[E]%
\\
\>[20]{}\mathbf{if}\;(\Varid{vT'}\mathbin{<}\Varid{diffT}){}\<[E]%
\\
\>[20]{}\hsindent{2}{}\<[22]%
\>[22]{}\mathbf{then}\;\Varid{return}\;(){}\<[E]%
\\
\>[20]{}\hsindent{2}{}\<[22]%
\>[22]{}\mathbf{else}\;\Varid{kernelSleep}\;(\Varid{vT'}\mathbin{-}\Varid{diffT}){}\<[E]%
\\
\>[20]{}\Varid{setVirtualTime}\;\Varid{vT'}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%%
\emph{sleep} proceeds by calculating the elapsed time, \emph{diffT}, 
and the new virtual time \emph{vT'}. If the new virtual time is less
than the elapsed time then no actual (kernel) sleeping happens. However,
if the new virtual time is ahead of the elapsed time, then the process
sleeps for the difference. Finally, the virtual time state is updated
with the new virtual time. 


\paragraph{Quotienting by non-time dependent functions}

In L, there is no expression which returns the current time; 
 \emph{getTime} belongs only to the model, not to the language.
That is, for all expressions $e$, then the denotation 
$\interp{e}$ factors through 


\subsection{Emitting overrun exceptions}

\paragraph{Overrun}

\paragraph{Overrun schedule}

\section{Related work}

There has been various work on reasoning about time in logic. For
example, modal CTL (Computational Tree Logic) has been extended with
time bounds for deadlines~\cite{emerson1991quantitative} (RCTL,
Real-Time Computational Tree Logic) and for soft deadlines with
probabilities on time bounds~\cite{hansson1994logic}. In these logics,
temporal modalities are indexed with time bounds, \eg{}, $AF^{\leq 50}
p$ means $p$ is true after at least $50$ ``time units'' (where $A$ is
the CTL connective for \emph{along all paths} and $F$ for
\emph{finally} (or \emph{eventually})). Our approach is less
prescriptive and explicit, but has some resemblance in the use of
\sleepOp{}. For example, the program $\sleep t ; P$ roughly
corresponds to $AF^{\leq t} \interp{P}$, \ie{}, after at leat $t$ then
whatever $P$ does will have happend. Our framework is not motivated by
logic and we do not have a model checking process for answering
questions such as, at time $t$ what formula hold (what statements have
been evluated).  The properties of Lemmas 1 to 5 however provide some
basis for programmers to reason about time in their programs. In
practice, we find that such reasoning can be done by children in a
completely informal but highly useful way.



\section{Epilogue}


\paragraph{Acknowledgements}

\bibliography{references}


\end{document}
