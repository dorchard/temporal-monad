\documentclass[preprint]{sigplanconf}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%


\usepackage{fancyvrb}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{xypic}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{url}
\usepackage{color}

\ifdefined\nolhs
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\else
\fi

\newcommand{\note}[1]{{\color{blue}{#1}}}

\newtheorem{lemma}{Lemma}
\theoremstyle{definition}
\newtheorem{definition}{Definition}

\newcommand{\play}{\mathsf{play}\;}
\newcommand{\sleep}{\mathsf{sleep}\;}
\newcommand{\playOp}{\textsf{play}}
\newcommand{\sleepOp}{\textsf{sleep}}
\newcommand{\lang}{SonicPi}

\newcommand{\vtime}[1]{[#1]_{\mathsf{v}}}
\newcommand{\etime}[1]{[#1]_{\mathsf{t}}}

\newcommand{\interp}[1]{\llbracket{#1}\rrbracket}

\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}

\authorinfo{Sam Aaron}{}{}
\authorinfo{Dominic Orchard}{}{}
\title{A programming model for temporal coordination (in music)}

\begin{document}
\maketitle

\begin{figure}[t]
\[
\begin{array}{l}
\play C \\
\play E \\ 
\play G \\
\sleep 1 \\
\play F \\
\play A \\
\play C \\
\sleep 0.5 \\
\play G \\
\play B \\
\play D
\end{array}
\]
\caption{Playing three chords in \lang{} with the second two chords played
closer together by $0.5s$.}
\end{figure}

The \sleepOp{} statement essentially imposes a minimum \emph{soft deadline}
(in the terminology of )

\paragraph{Terminology} 
We refer to closed (\ie{}, without free variables)
sequences of statements as \emph{programs}.

\begin{definition}
For a program $P$, then $\vtime{P}$ is the \emph{virtual time} that
elapses when running $P$ and $\etime{P}$ is the \emph{actual (kernel)
  time} that elapses when running $P$.
\end{definition}

\begin{definition}
\note{This is partial, there is no compositional definition for
$\etime{-}$ (proving this might be interesting, it can be
done by example).}
Since the \sleepOp{} operation increments virtual time, but also
causes kernel sleep then: $\vtime{\sleep t} = \etime{\sleep t} = t$,
and
%
\[
\vtime{P; Q} = \vtime{P} + \vtime{Q}
\]
\end{definition}

\begin{lemma}
For all programs $P$ then $\etime{P} \geq \vtime{P}$. 
\end{lemma}

\paragraph{Proof}
TODO

\begin{lemma}
For a program $P$ then:
%%
\begin{align*}
\etime{P; \sleep{} s} = 
 \begin{cases}
   s + \vtime{P} & \etime{P} \leq s \\
   \etime{P} & \etime{P} > s
 \end{cases}
\end{align*}
\end{lemma}

\begin{lemma}
For a program $P$ then
%%
\begin{align*}
\etime{\sleep{} s; P} = s + \etime{P}
\end{align*}
\end{lemma}


For example, consider subprograms $A$, $B$, $C$ interposed with two
sleep statements with lengths $s_1$ and $s_2$:
%
\begin{equation}
\begin{array}{l}
A \\
\sleep s_1 \\
B  \\
\sleep s_2 \\
C
\end{array}
\label{example:time1}
\end{equation}
%%
If $[A] = t_1$, $[B] = t_2$, $[C] = t_3$, then $[eq. \eqref{example:time1}] = 
s_1 + s_2 + t_3$, iff $t_1 \leq 1$ and $t_2 \leq 2$.

%\begin{equation*}
%\begin{array}{lllll}
%A & \multirow{2}{*}{\rule[1em]{0.6pt}{1.2em}} & \multirow{2}{*}{$t_1$} & 
%\multirow{4}{*}{\rule[1em]{0.6pt}{4em}} & \multirow{4}{*}{$t_1 + t_2 + 3$}
%\\
%\emph{sleep} \; 1 \qquad \\
%B &  \multirow{2}{*}{\rule[1em]{0.6pt}{1.2em}} & \multirow{2}{*}{$t_2$} \\
%\emph{sleep} \; 2
%\end{array}
%\end{equation*}

\subsection{Time monad}

The semantics of time in the \lang{} language is monadic, that is,
there is an underlying monad that describes the effectful component of
the language, relating to time. In the following, we use Haskell as
our meta language for the semantics (since it provides convenient
syntax for working with monads)\footnote{The source code for the monadic
model is avilable at \url{https://github.com/dorchard/time-monad}}. 

\newcommand{\TM}{\mathsf{TM}}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Temporal}\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Conid{T}\;((\Conid{Time},\Conid{Time})\to (\Conid{VTime}\to \Conid{IO}\;(\Varid{a},\Conid{VTime}))){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%%
Which maps a pair of two times, which will be the
start time of the computation and current time, to
a stateful computation over the \emph{IO} monad with
a single location storing a virtual time.

To model \lang{}, it is enough for \emph{Temporal} to have the
structure of an \emph{applicative functor}.  Recall the usual
applicative functor interface:
%%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;\Conid{Functor}\;\Varid{f}\Rightarrow \Conid{Applicative}\;\Varid{f}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{pure}{}\<[10]%
\>[10]{}\mathbin{::}\Varid{a}\to \Varid{f}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}(<\!\!\!*\!\!\!>)\mathbin{::}\Varid{f}\;(\Varid{a}\to \Varid{b})\to \Varid{f}\;\Varid{a}\to \Varid{f}\;\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%%
Thus, an instance for \emph{Temporal} 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Applicative}\;\Conid{Temporal}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{pure}\;\Varid{a}{}\<[21]%
\>[21]{}\mathrel{=}\Conid{T}\;(\lambda (\anonymous ,\anonymous )\to \lambda \Varid{vt}\to \Varid{return}\;(\Varid{a},\Varid{vt})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}(\Conid{T}\;\Varid{f})<\!\!\!*\!\!\!>(\Conid{T}\;\Varid{x})\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Conid{T}\;{}\<[12]%
\>[12]{}(\lambda (\Varid{startT},\Varid{nowT})\to \lambda \Varid{vT}\to {}\<[E]%
\\
\>[12]{}\hsindent{3}{}\<[15]%
\>[15]{}\mathbf{do}\;{}\<[19]%
\>[19]{}\Varid{thenT}{}\<[30]%
\>[30]{}\leftarrow \Varid{getCurrentTime}{}\<[E]%
\\
\>[19]{}(\Varid{x'},\Varid{vT'}){}\<[30]%
\>[30]{}\leftarrow \Varid{x}\;(\Varid{startT},\Varid{thenT})\;\Varid{vT}{}\<[E]%
\\
\>[19]{}(\Varid{f'},\Varid{vT''})\leftarrow \Varid{f}\;(\Varid{startT},\Varid{nowT})\;\Varid{vT'}{}\<[E]%
\\
\>[19]{}\Varid{return}\;(\Varid{f'}\;\Varid{x'},\Varid{vT''})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{align*}
\interp{\emph{statement}} & : \emph{Temporal} \, () \\
\interp{P; Q} & = (\lambda() \rightarrow \interp{P}) <\!\!\!*\!\!\!> \interp{Q} \\
\interp{\sleep t} & = \emph{sleep} \, \interp{t}
\end{align*}
%%
Note that $\interp{-}$ is overloaded in the rule for \sleepOp{} for (pure) expressions. 
The concrete interpreation of other statements in the language, such as \playOp, is
elided here since it does not relate directly to the temporal semantics. 

\begin{figure}[t]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{time},\Varid{start}\mathbin{::}\Conid{Temporal}\;\Conid{Time}{}\<[E]%
\\
\>[B]{}\Varid{time}{}\<[7]%
\>[7]{}\mathrel{=}\Conid{T}\;(\lambda (\anonymous ,\Varid{nowT})\to \lambda \Varid{vT}\to \Varid{return}\;(\Varid{nowT},\Varid{vT})){}\<[E]%
\\
\>[B]{}\Varid{start}\mathrel{=}\Conid{T}\;(\lambda (\Varid{startT},\anonymous )\to \lambda \Varid{vT}\to \Varid{return}\;(\Varid{startT},\Varid{vT})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{getVirtualTime}\mathbin{::}\Conid{Temporal}\;\Conid{VTime}{}\<[E]%
\\
\>[B]{}\Varid{getVirtualTime}\mathrel{=}\Conid{T}\;(\lambda (\anonymous ,\anonymous )\to \lambda \Varid{vT}\to \Varid{return}\;(\Varid{vT},\Varid{vT})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{setVirtualTime}\mathbin{::}\Conid{VTime}\to \Conid{Temporal}\;(){}\<[E]%
\\
\>[B]{}\Varid{setVirtualTime}\;\Varid{vT}\mathrel{=}\Conid{T}\;(\lambda \anonymous \to \lambda \anonymous \to \Varid{return}\;((),\Varid{vT})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{Simple \emph{Temporal} computations, used  by the model}
\end{figure}

The key primitive \emph{sleep} provides the semantics for \sleepOp{} as:
%%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{sleep}\mathbin{::}\Conid{VTime}\to \Conid{Temporal}\;(){}\<[E]%
\\
\>[B]{}\Varid{sleep}\;\Varid{delayT}\mathrel{=}\mathbf{do}\;{}\<[20]%
\>[20]{}\Varid{vT}{}\<[28]%
\>[28]{}\leftarrow \Varid{getVirtualTime}{}\<[E]%
\\
\>[20]{}\Varid{startT}{}\<[28]%
\>[28]{}\leftarrow \Varid{start}{}\<[E]%
\\
\>[20]{}\Varid{nowT}{}\<[28]%
\>[28]{}\leftarrow \Varid{time}{}\<[E]%
\\
\>[20]{}\mathbf{let}\;\Varid{diffT}\mathrel{=}\Varid{diffTime}\;\Varid{nowT}\;\Varid{startT}{}\<[E]%
\\
\>[20]{}\mathbf{let}\;\Varid{vT'}{}\<[30]%
\>[30]{}\mathrel{=}\Varid{vT}\mathbin{+}\Varid{delayT}{}\<[E]%
\\
\>[20]{}\mathbf{if}\;(\Varid{vT'}\mathbin{<}\Varid{diffT}){}\<[E]%
\\
\>[20]{}\hsindent{2}{}\<[22]%
\>[22]{}\mathbf{then}\;\Varid{return}\;(){}\<[E]%
\\
\>[20]{}\hsindent{2}{}\<[22]%
\>[22]{}\mathbf{else}\;\Varid{kernelSleep}\;(\Varid{vT'}\mathbin{-}\Varid{diffT}){}\<[E]%
\\
\>[20]{}\Varid{setVirtualTime}\;\Varid{vT'}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\paragraph{Quotienting by non-time dependent functions}

In L, there is no expression which returns the current time; 
 \emph{getTime} belongs only to the model, not to the language.
That is, for all expressions $e$, then the denotation 
$\interp{e}$ factors through 


\subsection{Emitting overrun exceptions}

\paragraph{Overrun}

\paragraph{Overrun schedule}



\end{document}
