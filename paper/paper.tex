\documentclass[preprint]{sigplanconf}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%


\usepackage{enumerate}
\usepackage{subfigure}
\usepackage{fancyvrb}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{xypic}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{url}
\usepackage{color}

\ifdefined\nolhs
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\else
\fi

\bibliographystyle{amsalpha}

\newcommand{\note}[1]{{\color{blue}{#1}}}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}


\CustomVerbatimEnvironment{SVerbatim}{Verbatim}{fontsize=\footnotesize,xleftmargin=0.5cm,xrightmargin=0.5cm,framesep=3mm,commandchars=\\\{\}}

\makeatletter
\newtheorem*{rep@lemma}{\rep@title}
\newcommand{\newreplemma}[2]{%
\newenvironment{rep#1}[1]{%
 \def\rep@title{#2 \ref{##1} (recap)}%
 \begin{rep@lemma}}%
 {\end{rep@lemma}}}
\makeatother

\newreplemma{lemma}{Lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\newreplemma{definition}{Definition}


\newcommand{\play}{\mathsf{play}\;}
\newcommand{\playOp}{\textsf{play}}

\newcommand{\sleep}{\mathsf{sleep}\;}
\newcommand{\sleepOp}{\textsf{sleep}}

\newcommand{\ksleep}{\mathsf{kernelSleep}\;}
\newcommand{\ksleepOp}{\textsf{kernelSleep}}

\newcommand{\lang}{SonicPi}

\newcommand{\vtime}[1]{[#1]_{\mathsf{v}}}
\newcommand{\etime}[1]{[#1]_{\mathsf{t}}}

\newcommand{\interp}[1]{\llbracket{#1}\rrbracket}

\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}

\authorinfo{Sam Aaron}
           {Computer Laboratory, University of Cambridge, UK}
           {sam.saaron\ensuremath{\mathord{@}}cl.cam.ac.uk}
\authorinfo{Dominic Orchard}
           {Computer Laboratory, University of Cambridge, UK}
           {dominic.orchard\ensuremath{\mathord{@}}cl.cam.ac.uk}
\authorinfo{Alan Blackwell}
           {Computer Laboratory, University of Cambridge, UK}
           {alan.blackwell\ensuremath{\mathord{@}}cl.cam.ac.uk}

\title{Temporal semantics for a live coding language} 
% A programming model for temporal coordination (in music)}

\begin{document}
\maketitle

\begin{abstract}
Sonic Pi is a music live coding language that has been designed for
educational use, as a first programming language. However, it is
not straightforward to achieve the necessary simplicity of a first language
in a music live coding setting, for reasons largely related to the
manipulation of time. The original version of Sonic Pi used a 'sleep'
function for managing time. However, whilst this approach was conceptually
simple, it resulted in badly timed music - especially when multiple musical
threads were executing concurrently. This paper describes an alternative
programming approach for timing (implemented in Sonic Pi v2.0) which
maintains syntactic compatibility with version 1, yet provides accurate
timing via specific interaction between real time and a "virtual time".
We provide a formal specification of the temporal behaviour of Sonic Pi,
motivated in relation to other recent approaches to the semantics of time in
live coding and general computation. We then define a monadic model of the
Sonic Pi temporal semantics which is sound with respect to this
specification, using Haskell as a metalanguage. 
\end{abstract}

\section{Introduction}
\label{sec:introduction}

\note{Introduction to SonicPi}

The underlying programming model of SonicPi provides a way to separate
the ordering of effects from the timing of
effects. Figure~\ref{three-chord-example} shows an example program
where three chords are played in sequence, combining simple notions of 
parallel, timed, and ordered effects.

The first three statements play the notes of a C major chord in
parallel.  A \sleepOp{} statement then provides a ``temporal barrier''
which blocks the computation from continuing until 1 second has
elapsed since the \emph{start} of the program (not since the end of
playing the notes). Once one second has elapsed, the next three
statements are executed which plays an F major chord. The next
\sleepOp{} means that the final chord is not played until 1.5 seconds
has elapsed since the start of the
program. Figure~\ref{three-chord-timing} illustrates the timing.

Thus, ``$\sleep{} t$'' communicates that, after it has been evaluated, at least 
$t$ seconds has elapsed since the last \sleepOp{}. This provides a minimum
time. In between calls to \sleepOp{}, any other statements can (with some limits)
be considered task parallel. 

In \lang{}, it is possible that a computation proceeding a \sleepOp{}
can overrun; that is, run longer than the sleep time.  Thus, the
programming model is not suitable for realtime systems requiring hard
deadlines but \sleepOp{} instead provides a \emph{soft deadline} (using
the terminology of Hansson and Jonsson~\cite{hansson1994logic}).

\note{Contributions}

\begin{itemize}
\item Explain the core principles of the language related to timing
(Section~\ref{}) and provide a monadic model this programming approach
(Section~\ref{}) (embedded in Haskell).

\item We show that the monadic approach can be composed with
  additional monads to capture other useful notions of effect in
  \lang{} programs, such as random numbers (Section~\ref{}).
\end{itemize}

%
The \lang{} was previously discussed in~\cite{aaron2013sonic}

\begin{SaveVerbatim}{example1}
play C
play E
play G
sleep 1
play F
play A
play C
sleep 0.5
play G
play B
play D
\end{SaveVerbatim}

\begin{figure}[t]
\subfigure[Three chord program in \lang{}]{
\begin{minipage}{0.46\linewidth}
%\[
%\hspace{-6em}
%\begin{array}{l}
%\play C \\
%\play E \\ 
%\play G \\
%\sleep 1 \\
%\play F \\
%\play A \\
%\play C \\
%\sleep 0.5 \\
%\play G \\
%\play B \\
%\play D \\
%\end{array}
%\]
\BUseVerbatim[fontsize=\footnotesize,baselinestretch=0.97]{example1} \\
\end{minipage}
\label{three-chord-example}
}
\subfigure[Timing of the three chord program]{
\begin{minipage}{0.46\linewidth}
\note{insert nice diagram that shows when the notes
occur over the 1.5s duration} \\
\end{minipage}
\label{three-chord-timing}
}
\caption{Playing three chords (C major, F major, G major) 
in \lang{} with the second two chords played
closer together by $0.5s$.}
\end{figure}

\subsection{Examples}
\label{sec:examples}

\note{Show a few more example programs here that
demonstrate the programming model.}

Figure~\ref{sleep-examples} shows four similar programs which each
have different internal behaviours for \sleepOp, illustrating its semantics. 
The first three take 3s to execute and the
last takes 4s to execute, with the behaviours:
%
\begin{enumerate}[(a)]
\item{3s -- sleeps for 1s then sleeps for 2s (two sleeps performed);}
\item{3s -- performs a computation lasting 1s, ignores
the first \sleepOp{} since its minimum duration has been reached, 
and then sleeps for 2s (one sleep performed);}
\item{3s -- performs a computation lasting 2s, which means that
the first \sleepOp{} is ignored, and the second \sleepOp{} waits
for only 1s to reach its minimum duration (half a sleep performed);}
\item{4s -- performs a computation lasting 2s, thus 
the first \sleepOp{} is ignored, then performs a computation lasting
2s, thus the second \sleepOp{} is ignored (no sleeps performed).}
\end{enumerate}


\begin{figure}[t]
\subfigure[Two sleeps]{
\begin{minipage}{0.18\linewidth}
\[
\hspace{-1em}
\begin{array}{l}
\sleep 1 \\
\sleep 2 \\ \\ \\ \\
\end{array}
\]
\end{minipage}
\label{sleep-examples:a}
}
\rule[-2em]{0.3pt}{5em}
%\hspace{1em}
% takes 3
\subfigure[One sleep]{
\begin{minipage}{0.23\linewidth}
\begin{center}
\[
\hspace{-0.5em}
\begin{array}{l}
\ldots \; \textit{\# lasts 1s} \\
\sleep 1 \\
\sleep 2 \\ \\  \\
\end{array}
\]
\end{center}
\end{minipage}
\label{sleep-examples:b}
}
\rule[-2em]{0.3pt}{5em}
%\hspace{1em}
% takes 3s
\subfigure[Half a sleep]{
\begin{minipage}{0.23\linewidth}
\begin{center}
\[
\hspace{-0.5em}
\begin{array}{l}
\ldots \; \textit{\# lasts 2s} \\
\sleep 1 \\
\sleep 2 \\ \\ \\
\end{array}
\]
\end{center}
\end{minipage}
\label{sleep-examples:c}
% takes 6
}
\rule[-2em]{0.3pt}{5em}
\subfigure[No sleeps]{
\begin{minipage}{0.23\linewidth}
\begin{center}
\[
\hspace{-0.5em}
\begin{array}{l}
\ldots \; \textit{\# lasts 2s} \\
\sleep 1 \\
\ldots \; \textit{\# lasts 2s} \\
\sleep 2 \\  \\
\end{array}
\]
\end{center}
\end{minipage}
}

\caption{Example programs with different \sleepOp{} behaviours}
\label{sleep-examples}
\end{figure}

\section{Model}

\paragraph{Terminology and notation}
We refer to closed sequences of statements (\ie{}, without free
variables) as \emph{programs}. Throughout, $P$, $Q$ range over programs,
and $s, t$ range over times (usually in seconds).

\subsection{Virtual time and real time}

The programming model of \lang{} distinguishes between the
\emph{actual time} elapsed since the start of a program $P$ which we
write as $\etime{P}$ and the \emph{virtual time} which is advanced by
\sleepOp{} statements which we write as $\vtime{P}$.

The \sleepOp{} operation is the way to change the virtual
time. Therefore, the definition of $\vtime{-}$ can be easily defined
over all programs:
%
\begin{definition}
Virtual time is specified for statements of \lang{} programs 
by the following (ordered) cases:
%
\begin{align*}
\vtime{\sleep t} & = t \\ 
\vtime{P; Q} & = \vtime{P} + \vtime{Q} \\
\vtime{-} & = 0
\end{align*}
%
\ie{}, the virtual time is $0$ 
for any statment other than \sleepOp{} or sequential composition.
\label{sleep-spec}
\end{definition}
\note{I haven't included here expressions, for example, if a call
to a function that did some sleeping happened, then this is not accounted
for here. I could be easily incldued though.}

\paragraph{Equality on time}

Providing exact deadlines in real-time systems is difficult due 
to noise and overhead caused by execution. We do not ignore
this problem in the programming model of \lang{} and the discussion here. 
We define the relation $\approx$ on actual time (non virtual times), where:
%%
\begin{equation}
s \approx t
\;
\equiv
\;
(t - \epsilon) \leq s \leq (t + \epsilon)
\end{equation}
%
for some value of $\epsilon$ which is the maximum negligible 
time value with respect to the application at hand. In the case of
\lang{}, this is equal to the scheduling delay for the SuperCollider
engine (and is machine dependent), which is roughly \note{X}.

\note{Discuss this further, may be
  able to say later that in some cases $\epsilon$ is the scheduling
  time for play statments?} 


The virtual time and actual time of a single sleep statement 
 are roughly the same, \ie{}, $\vtime{\sleep t} \approx
\etime{\sleep t}$ and thus $\etime{\sleep t} \approx t$ (by the
specification in Definition~\ref{sleep-spec}). This holds
only when \sleepOp{} is used in isolation, that is, when it is the
only statement in a program. As shown by the examples of
Section~\ref{sec:examples}, the use of $\sleep t$ in a program does
not mean that a program necessarily waits for $t$ seconds-- depending
on the context, it may wait for anywhere between $0$ and $t$ seconds.
 
\paragraph{Temporal properties of programs}

We outline here some important temporal properties of our \lang{} programs
that relates the virtual time and actual times. In Section~\ref{}, we
replay these lemmas and prove the soundness: that these lemmas hold of our model.

%For convenience, and to contrast with \sleepOp{}, we'll use an additional
%statement \ksleepOp{} here (which is not available in the actual language)
% which always sleeps for the number of seconds specified by its parameter.

\begin{lemma}
For some program $P$ and time $t$: 
%%
\begin{align*}
\etime{P; \sleep{} t} \approx
 \begin{cases}
   \etime{P} & (\vtime{P} + t) < \etime{P} \\
   \vtime{P} + t  & \textit{otherwise}
 \end{cases}
\end{align*}
%\begin{align*}
%\etime{P; \sleep{} t} = 
% \begin{cases}
%   \etime{P} & t < \etime{P} \\
%   \vtime{P} + t & t \geq \etime{P}
% \end{cases}
%\end{align*}
\label{lem:sleep-R}
\end{lemma}

\begin{lemma}
For some program $P$ and time $t$:
%%
\begin{align*}
\etime{\sleep{} t; P} \approx t + \etime{P}
\end{align*}
\label{lem:sleep-L}
\end{lemma}

\noindent
These two lemmas illuminate something of the semantics of sleep,
and its interaction with other statements in the language.

\begin{lemma}
For all programs $P$ then $\etime{P} \geq \vtime{P}$. 
\label{lemma-rel-etime-vtime}
\end{lemma}

\begin{lemma}
For all programs $P$ and $Q$ then:
%%
\begin{equation}
\vtime{P} + \vtime{Q} \leq \etime{P; Q} \lesssim \etime{P} + \etime{Q}
\end{equation}
\label{theorem:main}
\end{lemma}

\note{It's possible that these lemmas should be in a different order--
 we may need \ref{theorem:main} to prove \ref{lemma-rel-etime-vtime+}.}

From these lemmas we can reason about the evaluation time of 
programs. For example, consider subprograms $A$, $B$, $C$ where 
$\vtime{A} = \vtime{B} = \vtime{C} = 0$ interposed with two
sleep statements of duration $s_1$ and $s_2$:
%
\begin{equation}
\begin{array}{l}
A \\
\sleep s_1 \\
B  \\
\sleep s_2 \\
C
\end{array}
\label{example:time1}
\end{equation}
%%
Then by the above lemmas, we see that if $\etime{A} \leq s_1$ and
$\etime{B} \leq s_2$ then $\etime{eq. \eqref{example:time1}} = 
s_1 + s_2 + \etime{C}$.

%\begin{equation*}
%\begin{array}{lllll}
%A & \multirow{2}{*}{\rule[1em]{0.6pt}{1.2em}} & \multirow{2}{*}{$t_1$} & 
%\multirow{4}{*}{\rule[1em]{0.6pt}{4em}} & \multirow{4}{*}{$t_1 + t_2 + 3$}
%\\
%\emph{sleep} \; 1 \qquad \\
%B &  \multirow{2}{*}{\rule[1em]{0.6pt}{1.2em}} & \multirow{2}{*}{$t_2$} \\
%\emph{sleep} \; 2
%\end{array}
%\end{equation*}


\newcommand{\TM}{\mathsf{TM}}

\subsection{Monadic structure on computation}

In the following, we use Haskell as our meta language for the
semantics (since it provides convenient syntax for working with
monads)\footnote{The source code for the model is avilable at
  \url{https://github.com/dorchard/time-monad}}.
\lang{} computations are modelled by the \emph{Temporal} data type, defined:
%%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Temporal}\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Conid{T}\;((\Conid{Time},\Conid{Time})\to (\Conid{VTime}\to \Conid{IO}\;(\Varid{a},\Conid{VTime}))){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%
Thus, temporal computations map a pair of two times, which will be
the start time of the computation and current time, to a stateful
computation with a single location storing a virtual time, over the
\emph{IO} type.  The \emph{IO} computation provides underlying access
to the actual time from kernel.

The \emph{Monad} instance for \emph{Temporal} is then as follows:
%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Monad}\;\Conid{Temporal}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{return}\;\Varid{a}{}\<[16]%
\>[16]{}\mathrel{=}\Conid{T}\;(\mathbin{\char92 \char95 }\to \lambda \Varid{vT}\to \Varid{return}\;(\Varid{a},\Varid{vT})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\\[-1.5em]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\Conid{T}\;\Varid{p})\bind \Varid{q}{}\<[16]%
\>[16]{}\mathrel{=}\Conid{T}\;(\lambda (\Varid{startT},\Varid{nowT})\to \lambda \Varid{vT}\to {}\<[E]%
\\
\>[16]{}\hsindent{5}{}\<[21]%
\>[21]{}\mathbf{do}\;{}\<[25]%
\>[25]{}(\Varid{x},\Varid{vT'}){}\<[37]%
\>[37]{}\leftarrow \Varid{p}\;(\Varid{startT},\Varid{nowT})\;\Varid{vT}{}\<[E]%
\\
\>[25]{}\mathbf{let}\;(\Conid{T}\;\Varid{q'}){}\<[37]%
\>[37]{}\mathrel{=}\Varid{q}\;\Varid{x}{}\<[E]%
\\
\>[25]{}\Varid{thenT}{}\<[37]%
\>[37]{}\leftarrow \Varid{getCurrentTime}{}\<[E]%
\\
\>[25]{}\Varid{q'}\;(\Varid{startT},\Varid{thenT})\;\Varid{vT'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%
To ease understanding, we recall the types of \emph{return}
and \ensuremath{(\bind )} along with some intuition for their behaviour for
\emph{Temporal}:
%
\begin{itemize}
\item \ensuremath{\Varid{return}\mathbin{::}\Varid{a}\to \Conid{Temporal}\;\Varid{a}} lifts a pure value into a trivially
effectful computation by ignoring the time parameters and 
providing the usual pure state behaviour of returning the parameter state unchanged
(named \emph{vT} in this case). 

\item \ensuremath{(\bind )\mathbin{::}\Conid{Temporal}\;\Varid{a}\to (\Varid{a}\to \Conid{Temporal}\;\Varid{b})\to \Conid{Temporal}\;\Varid{b}} 
  composes two computations together.  The result of composing two
  temporal computations, with start time \emph{startT}, current time
  \emph{nowT}, and virtual time \emph{vT}, is the result of evaluating
  first the left-hand side at time \emph{nowT} and then right-hand side 
  at the new current time \emph{thenT}. 

  The expression \ensuremath{\Varid{getCurrentTime}\mathbin{::}\Conid{IO}\;\Conid{Time}} retrieves the time from
  the operation system.
\end{itemize}

To model the evaluation of a program, the \ensuremath{\Varid{runTime}} operation executes
a temporal computation inside of the \emph{IO} monad by providing the
start time of the computation and virtual time 0:
%%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{runTime}\mathbin{::}\Conid{Temporal}\;\Varid{a}\to \Conid{IO}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{runTime}\;(\Conid{T}\;\Varid{c})\mathrel{=}\mathbf{do}\;{}\<[21]%
\>[21]{}\Varid{startT}\leftarrow \Varid{getCurrentTime}{}\<[E]%
\\
\>[21]{}(\Varid{x},\anonymous )\leftarrow \Varid{c}\;(\Varid{startT},\Varid{startT})\;\mathrm{0}{}\<[E]%
\\
\>[21]{}\Varid{return}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%%
To illustrate the evalution of temporal computation and the
ordering and interleaving of calls to the operation system for the
current time, consider the program:
%%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{runTime}\;(\mathbf{do}\;\{\mskip1.5mu \Varid{f};\Varid{g};\Varid{h};\mskip1.5mu\}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
(where \ensuremath{\Varid{f}\mathrel{=}(\Conid{T}\;\Varid{f'}),\Varid{g}\mathrel{=}(\Conid{T}\;\Varid{g'}),\Varid{h}\mathrel{=}(\Conid{T}\;\Varid{h'})}) which 
desugars to the following \emph{IO} computation, 
after some simplification: 
%%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{do}\;{}\<[5]%
\>[5]{}\Varid{startT}{}\<[15]%
\>[15]{}\leftarrow \Varid{getCurrentTime}{}\<[E]%
\\
\>[5]{}(\anonymous ,\Varid{vT'}){}\<[15]%
\>[15]{}\leftarrow \Varid{f'}\;(\Varid{startT},\Varid{startT})\;\mathrm{0}{}\<[E]%
\\
\>[5]{}\Varid{thenT}{}\<[15]%
\>[15]{}\leftarrow \Varid{getCurrentTime}{}\<[E]%
\\
\>[5]{}(\anonymous ,\Varid{vT''})\leftarrow \Varid{g'}\;(\Varid{startT},\Varid{thenT})\;\Varid{vT'}{}\<[E]%
\\
\>[5]{}\Varid{thenT'}{}\<[15]%
\>[15]{}\leftarrow \Varid{getCurrentTime}{}\<[E]%
\\
\>[5]{}(\Varid{y},\anonymous ){}\<[15]%
\>[15]{}\leftarrow \Varid{h'}\;(\Varid{startT},\Varid{thenT'})\;\Varid{vT''})\;{}\<[E]%
\\
\>[5]{}\Varid{return}\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%
This illustrates the repeated calls to \ensuremath{\Varid{getCurrentTime}}, the
constant start time parameter, and the threading of virtual time state
throughout the computation. 

Figure~\ref{core-functions} shows a number of effectul operations of 
 the \emph{Temporal} monad that access the current time, the start time, get
and set the virtual time, and cause a kernel sleep. These
are used in the next part of the model. 

\paragraph{Interpreting \lang{} statements}

The following interpretation function $\interp{-}$ on \lang{} 
programs shows the mapping to the operations of the \emph{Temporal}
monad:
%%
\begin{align*}
\interp{\emph{statement}} & : \emph{Temporal} \, () \\
\interp{x = P; Q} & = \interp{P} \ensuremath{\bind (\lambda \Varid{x}\to } \interp{Q}) \\
\interp{P; Q} & = \interp{P} \ensuremath{\bind (\mathbin{\char92 \char95 }\to } \interp{Q}) \\
\interp{\sleep e} & = \emph{sleep} \, \interp{e}
\end{align*}
%%
Note that $\interp{-}$ is overloaded in the rule for \sleepOp{} for (pure) expressions. 
The concrete interpreation of other statements in the language, such as \playOp, is
elided here since it does not relate directly to the temporal semantics. 

The key primitive \emph{sleep} provides the semantics for \sleepOp{} as:
%%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{sleep}\mathbin{::}\Conid{VTime}\to \Conid{Temporal}\;(){}\<[E]%
\\
\>[B]{}\Varid{sleep}\;\Varid{delayT}\mathrel{=}\mathbf{do}\;{}\<[20]%
\>[20]{}\Varid{nowT}{}\<[30]%
\>[30]{}\leftarrow \Varid{time}{}\<[E]%
\\
\>[20]{}\Varid{vT}{}\<[30]%
\>[30]{}\leftarrow \Varid{getVirtualTime}{}\<[E]%
\\
\>[20]{}\mathbf{let}\;\Varid{vT'}{}\<[30]%
\>[30]{}\mathrel{=}\Varid{vT}\mathbin{+}\Varid{delayT}{}\<[E]%
\\
\>[20]{}\Varid{setVirtualTime}\;\Varid{vT'}{}\<[E]%
\\
\>[20]{}\Varid{startT}{}\<[30]%
\>[30]{}\leftarrow \Varid{start}{}\<[E]%
\\
\>[20]{}\mathbf{let}\;\Varid{diffT}\mathrel{=}\Varid{diffTime}\;\Varid{nowT}\;\Varid{startT}{}\<[E]%
\\
\>[20]{}\mathbf{if}\;(\Varid{vT'}\mathbin{<}\Varid{diffT}){}\<[E]%
\\
\>[20]{}\hsindent{2}{}\<[22]%
\>[22]{}\mathbf{then}\;\Varid{return}\;(){}\<[E]%
\\
\>[20]{}\hsindent{2}{}\<[22]%
\>[22]{}\mathbf{else}\;\Varid{kernelSleep}\;(\Varid{vT'}\mathbin{-}\Varid{diffT}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%
where \emph{sleep} proceeds first by getting the current time
\emph{nowT}, calculating the new virtual time \emph{vT'} and updating
the virtual time state. If the new virtual time is less than the
elapsed time \emph{diffT} since the start then no actual (kernel)
sleeping happens. However, if the new virtual time is ahead of the
elapsed time, then the process waits for the difference such that the
elapsed time equals the virtual time.


\begin{figure}[t]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{time}\mathbin{::}\Conid{Temporal}\;\Conid{Time}{}\<[E]%
\\
\>[B]{}\Varid{time}{}\<[7]%
\>[7]{}\mathrel{=}\Conid{T}\;(\lambda (\anonymous ,\Varid{nowT})\to \lambda \Varid{vT}\to \Varid{return}\;(\Varid{nowT},\Varid{vT})){}\<[E]%
\\
\>[B]{}\\[-1.5em]{}\<[E]%
\\
\>[B]{}\Varid{start}\mathbin{::}\Conid{Temporal}\;\Conid{Time}{}\<[E]%
\\
\>[B]{}\Varid{start}\mathrel{=}\Conid{T}\;(\lambda (\Varid{startT},\anonymous )\to \lambda \Varid{vT}\to \Varid{return}\;(\Varid{startT},\Varid{vT})){}\<[E]%
\\
\>[B]{}\\[-1.5em]{}\<[E]%
\\
\>[B]{}\Varid{getVirtualTime}\mathbin{::}\Conid{Temporal}\;\Conid{VTime}{}\<[E]%
\\
\>[B]{}\Varid{getVirtualTime}\mathrel{=}\Conid{T}\;(\lambda (\anonymous ,\anonymous )\to \lambda \Varid{vT}\to \Varid{return}\;(\Varid{vT},\Varid{vT})){}\<[E]%
\\
\>[B]{}\\[-1.5em]{}\<[E]%
\\
\>[B]{}\Varid{setVirtualTime}\mathbin{::}\Conid{VTime}\to \Conid{Temporal}\;(){}\<[E]%
\\
\>[B]{}\Varid{setVirtualTime}\;\Varid{vT}\mathrel{=}\Conid{T}\;(\mathbin{\char92 \char95 }\to \mathbin{\char92 \char95 }\to \Varid{return}\;((),\Varid{vT})){}\<[E]%
\\
\>[B]{}\\[-1.5em]{}\<[E]%
\\
\>[B]{}\Varid{kernelSleep}\mathbin{::}\Conid{RealFrac}\;\Varid{a}\Rightarrow \Varid{a}\to \Conid{Temporal}\;(){}\<[E]%
\\
\>[B]{}\Varid{kernelSleep}\;\Varid{t}\mathrel{=}{}\<[18]%
\>[18]{}\Conid{T}\;(\lambda (\anonymous ,\anonymous )\to \lambda \Varid{vT}\to {}\<[E]%
\\
\>[18]{}\hsindent{6}{}\<[24]%
\>[24]{}\mathbf{do}\;{}\<[28]%
\>[28]{}\Varid{threadDelay}\;(\Varid{round}\;(\Varid{t}\mathbin{*}\mathrm{1000000})){}\<[E]%
\\
\>[28]{}\Varid{return}\;((),\Varid{vT})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{Simple \emph{Temporal} computations, used  by the model}
\label{core-functions}
\end{figure}


\subsection{Soundness}

We replay the previous lemmas on the temporal behaviour of \lang{} programs,
and show that the monadic model is sound with respect to these, \ie{},
that the lemmas hold of the model. 

\noindent
\begin{repdefinition}{sleep-spec}
\begin{align*}
\vtime{\sleep t} & = t \\ 
\vtime{P; Q} & = \vtime{P} + \vtime{Q} \\
\vtime{-} & = 0
\end{align*}
\end{repdefinition}

\begin{proof}
For our model, the proof is straightforward. For the case of
$P; Q$, we rely on the monotonicity of virtual time: virtual
time is only ever increasing, and can only ever be incremented by sleep. 
\note{Could put more here}
\end{proof}

\begin{replemma}{lem:sleep-R}
For some program $P$ and time $t$: 
%%
\begin{align*}
\etime{P; \sleep{} t} \approx
 \begin{cases}
   \etime{P} & (\vtime{P} + t) < \etime{P} \\
   \vtime{P} + t  & \textit{otherwise}
 \end{cases}
\end{align*}
\end{replemma}

\begin{proof}
Our model interprets $(P; \sleep t)$ as:
%%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{runTime}\;(\mathbf{do}\;\{\mskip1.5mu \interp{P};\Varid{sleep}\;\Varid{t}\mskip1.5mu\}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%%
which desugars and simplifies to the following \emph{IO} computation:
%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{do}\;{}\<[5]%
\>[5]{}\Varid{startT}{}\<[16]%
\>[16]{}\leftarrow \Varid{getCurrentTime}{}\<[E]%
\\
\>[5]{}(\Varid{x},\Varid{vT'}){}\<[16]%
\>[16]{}\leftarrow \interp{P}\;(\Varid{startT},\Varid{startT})\;\mathrm{0}{}\<[E]%
\\
\>[5]{}\Varid{nowT}{}\<[16]%
\>[16]{}\leftarrow \Varid{getCurrentTime}{}\<[E]%
\\
\>[5]{}\mathbf{let}\;\Varid{vT''}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{vT'}\mathbin{+}\Varid{t}{}\<[E]%
\\
\>[5]{}\Varid{setVirtualTime}\;\Varid{vT''}{}\<[E]%
\\
\>[5]{}\mathbf{let}\;\Varid{diffT}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{diffTime}\;\Varid{nowT}\;\Varid{startT}{}\<[E]%
\\
\>[5]{}\mathbf{if}\;(\Varid{vT''}\mathbin{<}\Varid{diffT})\;{}\<[24]%
\>[24]{}\mathbf{then}\;\Varid{return}\;(){}\<[E]%
\\
\>[24]{}\mathbf{else}\;\Varid{kernelSleep'}\;(\Varid{vT''}\mathbin{-}\Varid{diffT}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%%
where \ensuremath{\Varid{kernelSleep'}\;\Varid{x}\mathrel{=}\Varid{threadDelay}\;(\Varid{round}\;(\Varid{x}\mathbin{*}\mathrm{1000000}))} is used
to simplify the code here (as per the definition of \emph{kernelSleep} in
Figure~\ref{core-functions}).

From this we see that $\emph{diffT} = \etime{P}$ and $\emph{vT'} = \vtime{P}$ and 
 $\emph{vT''} = \vtime{P} + t$. Therefore, the guard of the 
\ensuremath{\mathbf{if}} expression is $(\vtime{P} + t) < \etime{P}$.
If the updating of the virtual time state and the computing of 
the guard takes $e$ then the overall time taken is:
%%
\begin{align*}
\etime{P; \sleep{} t} = 
 \begin{cases}
   \etime{P} + e & (\vtime{P} + t) < \etime{P}  \\
   \etime{P} + e + (\vtime{P} + t) - \etime{P}  & \textit{otherwise}
 \end{cases}
\end{align*}
%%
which is equivalent to the statment of the lemma if $e \leq \epsilon$
and if the reduction to the interpretation to get to the above code 
takes less than $\epsilon$:
\begin{align*}
\etime{P; \sleep{} t} \approx 
 \begin{cases}
   \etime{P} & (\vtime{P} + t) < \etime{P} \\
   \vtime{P} + t  &  \textit{otherwise}
 \end{cases}
\end{align*}
\end{proof}

\note{I suppose this is ok- I'm a bit wary about saying the simplification
takes less than $\epsilon$. It surely does, but I am only hand waving. 
We could time $e$ though in the model and show it is less than the schedule
time. We could go further and time the analogous parts of the SonicPi implementation
to check that the real $e$ is less than $\epsilon$. This would be good.}

\begin{replemma}{lem:sleep-L}
For some program $P$ and time $t$:
%%
\begin{align*}
\etime{\sleep{} t; P} \approx t + \etime{P}
\end{align*}
\end{replemma}

\begin{proof}
Our models interprets $(\sleep t; P)$ as:
%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{runTime}\;(\mathbf{do}\;\{\mskip1.5mu \Varid{sleep}\;\Varid{t};\interp{P}\mskip1.5mu\}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%
which desugars and simplifies to the following \emph{IO} computation:
%
%\begin{code}
%do  setVirtualTime delayT
%    kernelSleep delayT 
%    interpP
%\end{code}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{do}\;{}\<[5]%
\>[5]{}\Varid{startT}\leftarrow \Varid{getCurrentTime}{}\<[E]%
\\
\>[5]{}\Varid{kernelSleep}\;\Varid{delayT}{}\<[E]%
\\
\>[5]{}\mathbf{let}\;(\Conid{T}\;\Varid{p})\mathrel{=}\interp{P}\;(){}\<[E]%
\\
\>[5]{}\Varid{thenT}\leftarrow \Varid{getCurrentTime}{}\<[E]%
\\
\>[5]{}\Varid{p}\;(\Varid{startT},\Varid{thenT})\;\Varid{delayT}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%
The code does a \ensuremath{\Varid{kernelSleep}} for $t$ and then continues with $P$ at
virtual time $t$, \ie{}, the time taken is $t + \interp{P}_t$.  In
desugaring and simplifying we have certainly elided some intermediate
steps in the computation (such as the guard test in sleep), which we
account for as part of the error $\epsilon$.
\end{proof}

\begin{replemma}{lemma-rel-etime-vtime}
For all programs $P$ then $\etime{P} \geq \vtime{P}$. 
\end{replemma}

\note{Rough notes for the proof}
\begin{proof}
By induction % possibly by strong induction?

$\interp{sleep t} = $
\ensuremath{\Varid{runTime}\;(\Varid{sleep}\;\Varid{t})} $\leadsto$ \ensuremath{\Varid{kernelSleep'}\;\Varid{delayT}}

$\etime{P;Q} = $
Inductive hypothesis: $\etime{P} \geq \vtime{P}$
              $\etime{Q} \geq \vtime{Q}$


\begin{itemize}
\item case $P = sleep t$ 

$\etime{sleep t; Q} = t + \etime{Q}$ 
$\vtime{sleep t; Q} = t + \vtime{Q}$
by inductive hypothesis $t + \etime{Q} \geq t + \vtime{Q}$.

\item case $Q = sleep t$

$\vtime{P; sleep t} = \vtime{P} + t$
By inductive hypothesis ($\etime{P} \geq \vtime{P}$) then


\begin{itemize}
\item case $\vtime{P} + t \leq \etime{P}$ then

$\etime{P; sleep t} = \etime{P}$ 
therefore $\etime{P; sleep t} \geq \vtime{P; sleep t}$
since $\etime{P} \geq \vtime{P} + t$ by the case.

\item case $\vtime{P} + t \geq \etime{P}$ then
 $\etime{P; sleep t} = \vtime{P} + t$
then $\etime{P; sleep t} \geq \vtime{P; sleep t}$
since $\etime{P; sleep t} = \vtime{P; sleep t}$. 
\end{itemize}

\note{This is actually quite hard. I think I can do it
by using Lemma 1 and 2 together with some reassociating, but
haven't time to sort it right now.}

\item case $P = P';P''$, $Q = Q';Q''$

reassociate 

case P' = sleep t, 

$\etime{P';Q'} = t + \etime{Q'}$
\end{itemize}

\end{proof}

\subsubsection{Monad laws}

\paragraph{Quotienting by non-time dependent functions}

\note{This section is more of a marker for myself (Dom), I need
to think about this later, but basically it is about showing
that the monad laws hold for our semantics (but not in general)}

In L, there is no expression which returns the current time; 
 \emph{getTime} belongs only to the model, not to the language.
That is, for all expressions $e$, then the denotation 
$\interp{e}$ factors through 

\subsection{Subsets of the semantics}

For the examples of Section~\ref{sec:introduction}, the full structure
of monad is not needed to give their semantics as there is no using of
binding between statements (and thus no dataflow). In these case just
an \emph{applicative functor}~\cite{mcbride2008functional} or even a
monoid would suffice. These can be derived from the monad structure
on \emph{Temporal} since all monads are applicative functors and all 
monads $m$ define a monoid over \ensuremath{\Varid{m}\;()}.

\paragraph{Applicative subset}

Applicative functors are described by the following interface in
Haskell:
%%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;\Conid{Functor}\;\Varid{f}\Rightarrow \Conid{Applicative}\;\Varid{f}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{pure}{}\<[10]%
\>[10]{}\mathbin{::}\Varid{a}\to \Varid{f}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}(<\!\!\!*\!\!\!>)\mathbin{::}\Varid{f}\;(\Varid{a}\to \Varid{b})\to \Varid{f}\;\Varid{a}\to \Varid{f}\;\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%
The \emph{Applicative} class describes how to compose effectul
computations encoded as values of type $f\ a$ (the effectful
computation of a pure value of type $a$). Thus, \emph{pure} constructs
a trivially effectful computation from a pure value and \ensuremath{<\!\!\!*\!\!\!>} (akin to
application) takes an effectful computation of a function and an
effectful computation of an argument and evaluates the two effects.

Our \emph{Temporal} denotations have the applicative functor
structure with the following derivation in terms of the monad:
%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Functor}\;\Conid{Temporal}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{fmap}\;\Varid{f}\;\Varid{x}\mathrel{=}\mathbf{do}\;\{\mskip1.5mu \Varid{x'}\leftarrow \Varid{x};\Varid{return}\;(\Varid{f}\;\Varid{x'})\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Applicative}\;\Conid{Temporal}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{pure}\;\Varid{a}{}\<[21]%
\>[21]{}\mathrel{=}\Varid{return}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{f}<\!\!\!*\!\!\!>\Varid{x}{}\<[21]%
\>[21]{}\mathrel{=}\mathbf{do}\;\{\mskip1.5mu \Varid{f'}\leftarrow \Varid{f};\Varid{x'}\leftarrow \Varid{x};\Varid{return}\;(\Varid{f'}\;\Varid{x'})\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%
Note that the definition of \ensuremath{<\!\!\!*\!\!\!>} here orders the effects left-to-right.

The interpretation of sequential composition for statements (with no
dataflow) is then $\interp{P; Q} = (\lambda() \rightarrow
\interp{P}) <\!\!\!*\!\!\!> \interp{Q}$.

\paragraph{Monoid subset}

Alternatively, the full structure of an applicative functor is
not even needed in this restricted case. Instead, a monoid
over \emph{Temporal ()} would suffice:
%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;\Conid{Monoid}\;\Varid{m}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{mempty}\mathbin{::}\Varid{m}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{mappend}\mathbin{::}\Varid{m}\to \Varid{m}\to \Varid{m}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Monoid}\;(\Conid{Temporal}\;())\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{mempty}{}\<[19]%
\>[19]{}\mathrel{=}\Varid{return}\;(){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{a}\mathbin{`\Varid{mappend}`}\Varid{b}\mathrel{=}\mathbf{do}\;\{\mskip1.5mu \Varid{a};\Varid{b};\Varid{return}\;()\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%% 
with the interpretation $\interp{P; Q} = \interp{P} \ensuremath{\mathbin{`\Varid{mappend}`}} Q$ and
where \ensuremath{\Varid{mempty}} provides a \emph{no-op}. 

\subsection{Alternate definition of \emph{sleep}}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{sleep'}\mathbin{::}\Conid{VTime}\to \Conid{Temporal}\;(){}\<[E]%
\\
\>[B]{}\Varid{sleep'}\;\Varid{delayT}\mathrel{=}\mathbf{do}\;{}\<[21]%
\>[21]{}\Varid{vT}{}\<[31]%
\>[31]{}\leftarrow \Varid{getVirtualTime}{}\<[E]%
\\
\>[21]{}\mathbf{let}\;\Varid{vT'}{}\<[31]%
\>[31]{}\mathrel{=}\Varid{vT}\mathbin{+}\Varid{delayT}{}\<[E]%
\\
\>[21]{}\Varid{setVirtualTime}\;\Varid{vT'}{}\<[E]%
\\
\>[21]{}\Varid{startT}{}\<[31]%
\>[31]{}\leftarrow \Varid{start}{}\<[E]%
\\
\>[21]{}\Varid{nowT}{}\<[31]%
\>[31]{}\leftarrow \Varid{time}{}\<[E]%
\\
\>[21]{}\mathbf{let}\;\Varid{diffT}\mathrel{=}\Varid{diffTime}\;\Varid{nowT}\;\Varid{startT}{}\<[E]%
\\
\>[21]{}\mathbf{if}\;(\Varid{vT'}\mathbin{<}\Varid{diffT}){}\<[E]%
\\
\>[21]{}\hsindent{4}{}\<[25]%
\>[25]{}\mathbf{then}\;\Varid{return}\;(){}\<[E]%
\\
\>[21]{}\hsindent{4}{}\<[25]%
\>[25]{}\mathbf{else}\;\Varid{kernelSleep}\;(\Varid{vT'}\mathbin{-}\Varid{diffT}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%
This alternate definition should reduce any oversleeping by minimising 
noise in the timing. For example, the virtual time is calculated 
and updated before the current time is retrieved in case the additional
time taken in updating the virtual time means that the elapsed time
catches up with the virtual time. 

To see the difference, consider Lemma~\ref{lem:sleep-R}:

\begin{replemma}{lem:sleep-R}
For some program $P$ and time $t$: 
%%
\begin{align*}
\etime{P; \sleep{} t} \approx 
 \begin{cases}
   \etime{P} & (\vtime{P} + t) < \etime{P} \\
   \vtime{P} + t  & \textit{otherwise}
 \end{cases}
\end{align*}
\end{replemma}
%
\noindent
If the above alternate definition \emph{sleep'} is used, then
the interpreation of $(P; \sleep t)$  
desugars and simplifies to the following:
%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{do}\;{}\<[5]%
\>[5]{}\Varid{startT}{}\<[16]%
\>[16]{}\leftarrow \Varid{getCurrentTime}{}\<[E]%
\\
\>[5]{}(\Varid{x},\Varid{vT'}){}\<[16]%
\>[16]{}\leftarrow \interp{P}\;(\Varid{startT},\Varid{startT})\;\mathrm{0}{}\<[E]%
\\
\>[5]{}\mathbf{let}\;\Varid{vT''}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{vT'}\mathbin{+}\Varid{t}{}\<[E]%
\\
\>[5]{}\Varid{setVirtualTime}\;\Varid{vT''}{}\<[E]%
\\
\>[5]{}\Varid{nowT}{}\<[16]%
\>[16]{}\leftarrow \Varid{getCurrentTime}{}\<[E]%
\\
\>[5]{}\mathbf{let}\;\Varid{diffT}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{diffTime}\;\Varid{nowT}\;\Varid{startT}{}\<[E]%
\\
\>[5]{}\mathbf{if}\;(\Varid{vT''}\mathbin{<}\Varid{diffT}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{then}\;\Varid{return}\;(){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{else}\;\Varid{kernelSleep}\;(\Varid{vT''}\mathbin{-}\Varid{diffT}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%%
which exhibits the temporal behaviour:
%% 
\begin{align*}
\etime{P; \sleep{} t} = 
 \begin{cases}
   \etime{P} + e_1 + e_2 & (\vtime{P} + t) < (\etime{P} + e_1) \\
   \vtime{P} + t + e_2 &  \textit{otherwise}
 \end{cases}
\end{align*}
%
where $e_1$ is the time taken by updating the virtual time and
$e_2$ is the time taken by the guard. This gives
a tighter bound on sleep behaviour that previously where the behaviour was:
%
\begin{align*}
\etime{P; \sleep{} t} = 
 \begin{cases}
   \etime{P} + e_1 + e_2 & (\vtime{P} + t) < \etime{P} \\
   \vtime{P} + t + e_1 + e_2 &  \textit{otherwise}
 \end{cases}
\end{align*}
%

\subsection{Emitting overrun warnings}

We extend the \ensuremath{\Conid{Temporal}} monad with an additional parameter for the
$\epsilon$ time (maximum allowable overrun) and an output stream for
sending ``warnings'' when overruns occur.

Overrun warnings are either \emph{strong}, when the real time 
is more than $\epsilon$ ahead of virtual time, or \emph{weak} when the real
time is less than $\epsilon$ ahead of virtual time. That is:
%%
\begin{itemize}
\item{$\etime{P} > (\vtime{P} + \epsilon) \Rightarrow \interp{P} \leadsto$ \emph{strong warning} }
\item{$(\vtime{P} + \epsilon) \leq \etime{P} > \vtime{P} \Rightarrow \interp{P} \leadsto$ \emph{weak warning}}
\end{itemize}
%%

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Warning}\mathrel{=}\Conid{Strong}\;\Conid{VTime}\mid \Conid{Weak}\;\Conid{VTime}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{data}\;\Conid{TemporalE}\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Conid{TE}\;(\Conid{VTime}\to \Conid{Temporal}\;(\Varid{a},[\mskip1.5mu \Conid{Warning}\mskip1.5mu])){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Monad}\;\Conid{TemporalE}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{return}\;\Varid{a}\mathrel{=}\Conid{TE}\;(\mathbin{\char92 \char95 }\to \Varid{return}\;(\Varid{a},[\mskip1.5mu \mskip1.5mu])){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}(\Conid{TE}\;\Varid{p})\bind \Varid{q}\mathrel{=}\Conid{TE}\;(\lambda \Varid{eps}\to \mathbf{do}\;(\Varid{a},\Varid{es})\leftarrow \Varid{p}\;\Varid{eps}{}\<[E]%
\\
\>[5]{}\hsindent{30}{}\<[35]%
\>[35]{}\mathbf{let}\;(\Conid{TE}\;\Varid{q'})\mathrel{=}\Varid{q}\;\Varid{a}{}\<[E]%
\\
\>[5]{}\hsindent{30}{}\<[35]%
\>[35]{}(\Varid{b},\Varid{es'})\leftarrow \Varid{q'}\;\Varid{eps}{}\<[E]%
\\
\>[5]{}\hsindent{30}{}\<[35]%
\>[35]{}\Varid{return}\;(\Varid{b},\Varid{es}\plus \Varid{es'})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\paragraph{Overrun}

\note{TODO: report warnings when overrun occurs- should be easy I think
by adding stuff to sleep.}

\paragraph{Overrun schedule}

\note{TOOD: Again pretty easy, just need some info in the monad
to say what counts as a bad overrun}

\section{Related work}

There has been various work on reasoning about time in logic. For
example, modal CTL (Computational Tree Logic) has been extended with
time bounds for deadlines~\cite{emerson1991quantitative} (RCTL,
Real-Time Computational Tree Logic) and for soft deadlines with
probabilities on time bounds~\cite{hansson1994logic}. In these logics,
temporal modalities are indexed with time bounds, \eg{}, $AF^{\leq 50}
p$ means $p$ is true after at least $50$ ``time units'' (where $A$ is
the CTL connective for \emph{along all paths} and $F$ for
\emph{finally} (or \emph{eventually})). Our approach is less
prescriptive and explicit, but has some resemblance in the use of
\sleepOp{}. For example, the program $\sleep t ; P$ roughly
corresponds to $AF^{\leq t} \interp{P}$, \ie{}, after at leat $t$ then
whatever $P$ does will have happend. Our framework is not motivated by
logic and we do not have a model checking process for answering
questions such as, at time $t$ what formula hold (what statements have
been evluated).  The properties of Lemmas 1 to 5 however provide some
basis for programmers to reason about time in their programs. In
practice, we find that such reasoning can be done by children in a
completely informal but highly useful way.



\section{Epilogue}

\note{TODO}

\paragraph{Acknowledgements}

\bibliography{references}

\appendix



\paragraph{Proof} (of Theorem~\ref{theorem:main})
\note{These are just rough notes}
Since sequential composition is associative, we can reassociate
$P; Q$ such that $P = P_1; P'$ where $P_1$ is a single statement

\begin{itemize}
\item $P = \sleep t$

\begin{align*}
\begin{array}{ll}
       & \etime{\sleep t; Q} \\[0.5em]
\equiv & \; \{\textit{Lemma}~\ref{lem:sleep-L}\} \\[0.1em]
       & s + \etime{Q} \\[0.5em]
\equiv & \; \{\textit{Definition}~\ref{}\} \\[0.1em]
       & \etime{\sleep t} + \etime{Q}
\end{array}
\end{align*}

\item $Q = \sleep t$ by Lemma~\ref{lem:sleep-R} then 
there are two cases:

\begin{itemize}
\item $\etime{P} \leq t$ then:

\begin{align*}
\begin{array}{ll}
       & \etime{P; \sleep t} \\[0.5em]
\equiv & \; \{\textit{Lemma}~\ref{lem:sleep-R}\} \\[0.1em]
       & \vtime{P} + t \\[0.5em]
\equiv & \; \{\textit{Definition}~\ref{sleep-spec}\} \\[0.1em]
       & \vtime{P} + \vtime{\sleep t}
\end{array}
\end{align*}

\item $\etime{P} > t$ then:

\begin{align*}
\begin{array}{ll}
       & \etime{P; \sleep t} \\[0.5em]
\equiv & \; \{\textit{Lemma}~\ref{lem:sleep-R}\} \\[0.1em]
       & \etime{P} \\[0.5em]
\leq   & \etime{P} + \etime{\sleep t}
\end{array}
\end{align*}

\end{itemize}

\item $P = P';P'', Q = Q';Q''$

Ressociate so that $P'; (P''; (Q'; Q''))$ then

By induction:
%%
\begin{align}
\vtime{P'} + \vtime{P''} \leq \etime{P'; P''} \leq \vtime{P'} + \vtime{P''} \\
\vtime{Q'} + \vtime{Q''} \leq \etime{Q'; Q''} \leq \vtime{Q'} + \vtime{Q''} \\
\end{align}

and
\note{STUCK!}
\end{itemize}


\end{document}
